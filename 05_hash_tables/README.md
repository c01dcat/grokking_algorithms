# 散列表

* 结合散列函数和数组可以创建散列表（hash table）这种数据结构。

## 缓存

缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中!

## 冲突

* 冲突（collision）：给两个键分配的位置相同。
* 处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。

## 性能

* 在平均情况下，散列表执行各种操作的时间都为 O(1)。O(1) 被称为常量时间。
* 在最糟情况下，散列表所有操作的运行时间都为 O(n) —— 线性时间。

要避免冲突，需要有：较低的填装因子; 良好的散列函数。

填装因子 = 散列表包含的元素数/位置总数。

填装因子大于 1 意味着商品数量超过了数组的位置数。一旦填装因子开始增大，就需要在散列表中添加位置，这被称为调整长度（resizing）。  
填装因子越低，发生冲突的可能性越小, 散列表的性能越高。一个不错的经验规则是：一旦填装因子大于 0.7，就调整散列表的长度。

平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为 O(1)。